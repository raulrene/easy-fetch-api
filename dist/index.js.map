{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e307664a8ab86642e9ac","webpack:///./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtCA;;AAEA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,iBAAgB,gCAAgC;AAChD,0BAAyB,8CAA8C;AACvE;AACA;AACA;AACA,uCAAsC,sBAAsB;AAC5D;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB;AACA,gCAA+B,GAAG;AAClC;AACA,kCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,iBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,cAAa;AACb;AACA,kCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,mBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,cAAa;AACb;AACA,kCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,kBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,cAAa;AACb;AACA,kCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,sBAAqB,+BAA+B;AACpD,0BAAyB,2DAA2D;AACpF,kCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,oBAAmB,gCAAgC;AACnD,0BAAyB,wDAAwD;AACjF,kCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA,gBAAe,OAAO,mDAAmD;AACzE,gBAAe,SAAS;AACxB;AACA,yBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EasyFetchApi\"] = factory();\n\telse\n\t\troot[\"EasyFetchApi\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e307664a8ab86642e9ac\n **/","class Api {\n\n    /**\n     * Set global headers instead of setting the same headers on each call.\n     * @param headers {Object} headers object\n     */\n    static setHeaders(headers) {\n        Api.headers = {};\n        if (typeof headers === 'object') {\n            Api.headers = headers;\n        }\n    }\n\n    /**\n     * Make a GET request\n     *\n     * @param {String} url API url to make request to\n     * @param {Object} [headers] HTTP Headers\n     * @param {Object} [query] Query object\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static get({ url, headers, query, callback }) {\n        const request = { method: 'GET', url, headers: Object.assign({}, Api.headers, headers) };\n        if (query) {\n            const qs = Object.keys(query)\n                .map(k => {\n                    let keyValue = `${encodeURIComponent(k)}=`;\n                    if (typeof query[k] === 'object') {\n                        keyValue += encodeURIComponent(JSON.stringify(query[k]));\n                    } else {\n                        keyValue += encodeURIComponent(query[k]);\n                    }\n                    return keyValue;\n                })\n                .join('&');\n            request.url += `?${qs}`;\n        }\n        return this.makeRequest({ request, callback });\n    }\n\n    /**\n     * Make a PUT request\n     *\n     * @param {String} url API url to make request to\n     * @param {Object} data The data to be updated\n     * @param {Object} [headers] HTTP Headers\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static put({ url, data, headers, callback }) {\n        const request = {\n            method: 'PUT',\n            url,\n            body: JSON.stringify(data),\n            headers: Object.assign({}, {\n                Accept: 'application/json',\n                'Content-Type': 'application/json'\n            }, Api.headers, headers)\n        };\n        return this.makeRequest({ request, callback });\n    }\n\n    /**\n     * Make a PATCH request\n     *\n     * @param {String} url API url to make request to\n     * @param {Object} data The data to be updated\n     * @param {Object} [headers] HTTP Headers\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static patch({ url, data, headers, callback }) {\n        const request = {\n            method: 'PATCH',\n            url,\n            body: JSON.stringify(data),\n            headers: Object.assign({}, {\n                Accept: 'application/json',\n                'Content-Type': 'application/json'\n            }, Api.headers, headers)\n        };\n        return this.makeRequest({ request, callback });\n    }\n\n    /**\n     * Make a POST JSON request\n     *\n     * @param {String} url API url to make request to\n     * @param {Object} data The data to be inserted\n     * @param {Object} [headers] HTTP Headers\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static post({ url, data, headers, callback }) {\n        const request = {\n            method: 'POST',\n            url,\n            body: JSON.stringify(data),\n            headers: Object.assign({}, {\n                Accept: 'application/json',\n                'Content-Type': 'application/json'\n            }, Api.headers, headers)\n        };\n        return this.makeRequest({ request, callback });\n    }\n\n    /**\n     * Make a POST form data request\n     *\n     * @param {String} url API url to make request to\n     * @param {Object} data The data to be inserted\n     * @param {Object} [headers] HTTP Headers\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static postForm({ url, data, headers, callback }) {\n        const request = { method: 'POST', url, body: data, headers: Object.assign({}, Api.headers, headers) };\n        return this.makeRequest({ request, callback });\n    }\n\n    /**\n     * Make a DELETE request\n     *\n     * @param {String} url API url to make request to\n     * @param {Object} [headers] HTTP Headers\n     * @param {String} [query] Query string\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static delete({ url, headers, query, callback }) {\n        const request = { method: 'DELETE', url, query, headers: Object.assign({}, Api.headers, headers) };\n        return this.makeRequest({ request, callback });\n    }\n\n    /**\n     * Make a generic request\n     *\n     * @param {Object} request Request to be made. Must be of the form: {method, url, query [optional]}\n     * @param {Function} [callback] Function to be run after the server responds\n     */\n    static makeRequest({ request, callback }) {\n        const headers = request.headers || {};\n\n        // Don't set the body if it's a GET request as it will crash on Microsoft Edge\n        const params = {\n            headers,\n            method: request.method || 'GET'\n        };\n        if (params.method !== 'GET') {\n            params.body = request.body || null;\n        }\n\n        // Do the API Request\n        return fetch(request.url, params)\n            .then(res => res.json())\n            .then(res => {\n                callback && callback(res);\n                return res;\n            })\n            .catch(err => {\n                callback && callback(err);\n            });\n    }\n}\n\nexports.setHeaders = Api.setHeaders;\nexports.get = Api.get;\nexports.put = Api.put;\nexports.put = Api.patch;\nexports.post = Api.post;\nexports.postForm = Api.postForm;\nexports.delete = Api.delete;\nexports.makeRequest = Api.makeRequest;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}